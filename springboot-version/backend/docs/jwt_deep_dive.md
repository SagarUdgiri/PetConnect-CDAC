# üéì JWT & Spring Security: Interview Master Guide

This document serves as a complete walkthrough and study guide for implementing Spring Security with JWT (JSON Web Tokens).

---

## üèóÔ∏è Implementation Hierarchy (The "Order")

When building a secure Spring Boot application from scratch, follow this sequence:

### 1. The Setup (Tools)
- **Dependencies**: Add `spring-boot-starter-security` and `jjwt` (Java JWT library).
- **Properties**: Set `jwtSecret` (your private key) and `jwtExpirationMs` in `application.properties`.

### 2. The Identity Bridge (User Connection)
- **`UserDetailsImpl`**: A wrapper for your `User` entity that Spring Security understands.
- **`UserDetailsServiceImpl`**: The service that talks to your Database to find a user by their username.

### 3. The Token Factory (`JwtUtils`)
- Create a utility class to:
    - **Generate** a token (after login).
    - **Validate** a token (for every subsequent request).
    - **Parse** a token (extract username).

### 4. The Security Gate (`JwtAuthenticationFilter`)
- A filter that intercepts **every single request**.
- If a valid JWT is found in the `Authorization` header, it sets the authentication in Spring's Security Context.

### 5. The Command Center (`SecurityConfig`)
- Configure which paths are public (e.g., `/api/auth/**`) and which are private.
- Set the `PasswordEncoder` (BCrypt).
- Plug the `JwtAuthenticationFilter` into the security chain.

---

## üîç JWT Anatomy: How it Works

A JWT is composed of three parts separated by dots: `header.payload.signature`

1.  **Header**: Contains metadata (e.g., Algorithm: HS256).
2.  **Payload (Claims)**: Contains the details (Username, Expiration, Roles). **Note**: Base64 encoded, not encrypted.
3.  **Signature**: Created by taking the `Header` + `Payload` and signing it with your `jwtSecret`. This ensures the token hasn't been tampered with.

---

## üí° Interview Concepts: Stateless vs. Stateful

### Session-Based (Stateful)
- Server creates a "Session ID" and stores it in memory (RAM).
- Client stores the ID in a Cookie.
- **Problem**: If you have 10 servers, all 10 must share the same session memory, which is hard to scale.

### Token-Based (Stateless / JWT)
- Server creates a JWT and gives it to the client.
- Server **does not store** anything in memory.
- Client sends the JWT in the header for every request.
- **Benefit**: Any server can validate the token using the `jwtSecret` without talking to a database or shared memory. Perfect for scaling!

---

## ‚ùì Common Interview Questions

**Q: Where do you store the password in a JWT?**
**A:** Never! The payload is Base64 encoded, meaning anyone can read it. Only store non-sensitive data like `username` or `roles`.

**Q: How do you log out a user with JWT?**
**A:** Since JWT is stateless, the server doesn't control the token after it's issued. Logout is usually handled by the **Frontend** (deleting the token from local storage). If you need server-side logout, you must implement a "Token Blacklist" in Redis.

**Q: What is BCrypt and why use it?**
**A:** BCrypt is a "Salted Hashing" algorithm. It turns "password123" into a long random string. It is safe because it includes a "salt" (randomness) that makes "Rainbow Table" attacks impossible.

**Q: What happens if the `jwtSecret` is leaked?**
**A:** Every single token ever issued becomes forged. A hacker could create a token for any user (including Admin). You must rotate the secret immediately.

---

## üõ†Ô∏è Practice Roadmap
1. Start with a plain Spring Web app.
2. Add Security and look at the "Default Login Page".
3. Disable the default login and try to make your own "Login" endpoint that returns a hardcoded string.
4. Replace that hardcoded string with a JWT generated by your `JwtUtils`.
5. Add the `JwtAuthenticationFilter` to lock your other APIs.
